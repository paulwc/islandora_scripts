#!/usr/bin/env drush

#<?php
/**
 * This script is intended to remove multiple versions of a datastream that are the same
 * and grouped together in the versions list. It uses the checksum value of the oldest datastream
 * version and compares it to the next most recent.
 * 
 * If an object datastream does not have a checksum it is NOT skipped and is checked against the
 * next version's checksum. Two consecutive datastream versions without checksums are considered IDENTICAL.
 * 
 * Example: if we list all versions of a datastream, starting from the oldest version and 'AAA' denotes a
 * datastream checksum value, we can represent the steps of this script from left to right
 *  
 * AAA -> AAA -> AAA  
 * AAA -> BBB -> BBB
 * AAA -> BBB -> CCC
 * BBB -> CCC -> DDD
 * BBB -> DDD -> EEE
 * CCC -> EEE -> AAA
 * DDD -> AAA
 * EEE
 * AAA
 * 
 * 9 versions down to 6 versions
 * 
 * Usage: pass the name of the collection to the script as the first argument
 *
 * Example: drush php-script purgeDSVersions.php collection_name
 *
 * @author Paul Church
 * @date July 2014
 */


/**
 * A note about the TUQUE purgeDatastream API call:
 * 
 * startDT and endDT are inclusive, so we need to subtract time from the
 * endDT value if we want to keep the most recent version of the
 * datastream or add time if we want to keep the oldest version of the ds
 */


/**
 * Creates a custom formatted ISO8601-ish datetime string
 * from a datastream array generated by the 
 * getDatastreamHistory() function
 * 
 * 
 * @param unknown $dsObject
 * @param boolean $modify optional, a string to modify the datetime, ex) "-1 second"
 * @return string
 */
function createCustomDT($dsObject, $modify='') 
{
    $dt = new DateTime($dsObject['dsCreateDate']);
    
    if (!$modify=='') {
        $dt->modify($modify);
    }
    
    // create datetime string to conform to values expected by fedora API
    $customDT = date_format($dt, 'Y-m-d\TH:i:s.u');
    $customDT = substr($customDT, 0, count($customDT)-4) . "Z";
    
    return $customDT;
}

/**
 * Creates a custom formatted ISO8601-ish datetime string with 
 * 3 digits of microseconds from a datastream object generated
 * by the getDatastreamHistory() function
 * 
 * Example: 2014-07-08T20:21:01.223Z
 * 
 * If a "-1" or "+1" is passed to this function, it will subtract or delete
 * one microsecond from the datetime string and return it
 * 
 * $dsObject['dsCreateDate'] = '2014-07-08T20:21:01.223Z'
 * Example: createMicrosecondDT($dsObject, "-1")
 * will return '2014-07-08T20:21:01.222Z'
 * 
 * 
 * @param array $dsObject a datastream object generated by the getDatastreamHistory() function
 * @param string $modify (optional) either a '-1' or a '+1' 
 * @return string
 */
function createMicrosecondDT($dsObject, $modify='')
{
    $dt = new DateTime($dsObject['dsCreateDate']);
    /* Microseconds as stored in a DateTime object are 6 digits long
     * but we only want 3 digits, so we chop off the last 3 digits
     * Ex: input: dt = 2014-07-08T20:21:01.223Z; 
     * $microseconds = $dt->format('u');  
     * $microseconds would equal "223000"
     * Note the un-needed extra 3 zeroes at the end
     */    
    $microseconds = substr($dt->format('u'), 0, 3);
    
    if (!$modify=='') {
        
        if ($modify == '-1') {
            if ($microseconds == '000') {
                $dt->modify('-1 second');
                $customDT = date_format($dt, 'Y-m-d\TH:i:s.') . '999Z';
                return $customDT;
            }
            $microseconds -= 1;
        }
        else if ($modify == '+1') {
            if ($microseconds == '999') {
                $dt->modify('+1 second');
                $customDT = date_format($dt, 'Y-m-d\TH:i:s.') . '000Z';
                return $customDT;
            }
            $microseconds += 1;
        }
    }
    
    // create datetime string to conform to values expected by fedora API
    $customDT = date_format($dt, 'Y-m-d\TH:i:s.') . $microseconds . "Z";
    
    return $customDT;
    
}

/**
 * Taken from stackoverflow: 
 * https://stackoverflow.com/questions/2510434/format-bytes-to-kilobytes-megabytes-gigabytes
 * 
 * @param unknown $size
 * @param number $precision
 * @return string
 */
function formatBytes($size, $precision = 2)
{
    $base = log($size) / log(1024);
    $suffixes = array('', 'kB', 'MB', 'GB', 'TB');

    return round(pow(1024, $base - floor($base)), $precision) . $suffixes[floor($base)];
}


// grab the first user supplied parameter as the name of the collection
$collection = drush_shift();

if (! $collection) {
    drush_print("***Error: please provide the name of the collection as the first argument");
    drush_print("Example: drush scr purgeDSVersions.php islandora:collection_name_here FULL_TEXT");
    return;
}

// grab the second user supplied paramter as the name of the datastream we care about
$dslabel = drush_shift();

if (! $dslabel) {
    drush_print("***ERROR: please provide the name of the datastream label as the second argument");
    drush_print("Example: drush scr purgeDSVersions.php islandora:collection_name_here FULL_TEXT");
    return;
}

// include all php files necessary for Tuque
foreach (glob("/var/www/drupal/htdocs/sites/all/libraries/tuque/*.php") as $filename) {
    require_once ($filename);
}

// repository connection parameters
$url = 'localhost:8080/fedora';
$username = 'fedoraAdmin';
$password = 'fedoraAdmin';

// set up connection and repository variables
$connection = new RepositoryConnection($url, $username, $password);
$api = new FedoraApi($connection);
$repository = new FedoraRepository($api, new SimpleCache());
$api_m = $repository->api->m; // Fedora management API
$api_a = $repository->api->a; // Fedora Access API

// query to grab all pdf collection objects from the repository
$sparqlQuery = "SELECT ?s
                FROM <#ri>
                WHERE {
                    ?s <info:fedora/fedora-system:def/relations-external#isMemberOfCollection>
                    <info:fedora/$collection> .
                }";

// run query
drush_print("\nQuerying repository for all PDF objects...");
$allPDFObjects = $repository->ri->sparqlQuery($sparqlQuery);
drush_print("Query complete\n");

// check number of objects in the collection to make sure we have some
$totalNumObjects = count($allPDFObjects);
if ($totalNumObjects <= 0) {
    drush_print("***Error: no objects found in the given collection. Check the collection name.");
    drush_print("***No processing was completed. Exiting.");
    return;
} else {
    drush_print("There are $totalNumObjects objects to be processed");
}

// establish a counter for how many objects we edit
$objectsChanged = 0;

$spaceFreed = 0;

$startingDSNumber = 0;
$endingDSNumber = 0;

$dsToDelete = 0;

$objectsWithProblems = array();
$followsThePattern = array();
$skippedObjects = array();


drush_print("\nBeginning main processing loop\n");
for ($counter = 0; $counter < $totalNumObjects; $counter ++) {
    // grab the next object from the result set
    $theObject = $allPDFObjects[$counter];

    // increment the counter shown to the user
    $realCount = $counter + 1;
    drush_print("Processing record $realCount of $totalNumObjects");

    // grab the PID value from the object array
    $objectPID = $theObject['s']['value'];


    /***************TESTING*****************/
//     $pid = 'islandora:1';
    /***************************************/
    
    $dshistory = $api_m->getDatastreamHistory($objectPID, $dslabel); //NB: ds's are returned in order from most to least recent
    $oldestToNewestDS = array_reverse($dshistory);
    $startingDSNumber += count($oldestToNewestDS);
//     drush_print("Datastream array before pruning");
//     print_r($oldestToNewestDS);
//     drush_print("************************************************");
    // print_r($dshistory);
    // print_r($dshistory[0]);
    // print_r($dshistory[count($dshistory)-1]);
    
//     return;

    $oldestDS = $oldestToNewestDS[0];
    $oldestDSChecksum = $oldestDS['dsChecksum'];
    
    // if the oldest version of this DS has no checksum...
    if ($oldestDSChecksum == 'none' || empty($oldestDSChecksum)) {
        
        // if the second oldest version of this DS has a checksum...
        if (!empty($oldestToNewestDS[1]['dsChecksum'])) {
            
            $followsThePattern[] = $objectPID;
            drush_print("$objectPID matches the pattern");

            try {
                $oldestDSVersionContent = $api_a->getDatastreamDissemination($objectPID, $dslabel, $oldestDS['dsCreateDate'], NULL);
                $computedHash = hash('sha256', $oldestDSVersionContent);

                // if the hash of the oldest version of the DS's content (computed) equals the
                // hash of the most recent DS's content (stored) then we can delete the oldest 
                // version of the DS as it is exactly the same as the most recent version
                if ($oldestToNewestDS[1]['dsChecksum'] === $computedHash) {
                    drush_print("Deleting the OBJ.0 datastream as the hashes are the same");
                    
                    $spaceFreed += $oldestDS['dsSize'];	
                    
                    // delete the .0 datastream (oldest version)
                    $api_m->purgeDatastream($objectPID, $dslabel, array(
                        'startDT' => $oldestDS['dsCreateDate'],
                        'endDT' => $oldestDS['dsCreateDate'],
                        'logMessage' => "Deleting $objectPID $dslabel.0 datastream",
                    ));
                    $dsToDelete++;
                }
            } catch (Exception $e) {
                drush_print("Skipping object $objectPID");
                $skippedObjects[] = $objectPID;
                continue;
            }
        } 
    }
    
}

print "\n";

$theCount = count($followsThePattern);
drush_print("There are $theCount number of datastreams out of $totalNumObjects that match the pattern");
drush_print("We deleted $dsToDelete OBJ.0 datastreams");
drush_print("We freed " . formatBytes($spaceFreed, 3) . " of space");
if (!empty($skippedObjects)) {
	drush_print("We skipped " . count($skippedObjects) . " objects due to issues");
	foreach ($skippedObjects as $skip) {
		drush_print("Skipped: $skip");
	}
}

return;

